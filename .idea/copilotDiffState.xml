<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/heypudu/heypudu/data/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/heypudu/heypudu/data/UserRepository.kt" />
              <option name="originalContent" value="package com.heypudu.heypudu.data&#10;&#10;import android.net.Uri&#10;import com.google.firebase.auth.AuthResult&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.storage.FirebaseStorage&#10;import AppDatabase&#10;import androidx.room.Room&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.withContext&#10;import android.content.Context&#10;&#10;class UserRepository(&#10;    private val auth: FirebaseAuth = FirebaseAuth.getInstance(),&#10;    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance(),&#10;    private val storage: FirebaseStorage = FirebaseStorage.getInstance()&#10;) {&#10;&#10;    suspend fun createUser(email: String, password: String): AuthResult = withContext(Dispatchers.IO) {&#10;        // No hacemos signOut aquí: que lo controle el ViewModel si lo requiere&#10;        auth.createUserWithEmailAndPassword(email, password).await()&#10;    }&#10;&#10;    suspend fun sendEmailVerification(): Unit = withContext(Dispatchers.IO) {&#10;        val user = auth.currentUser ?: throw IllegalStateException(&quot;No authenticated user&quot;)&#10;        user.sendEmailVerification().await()&#10;    }&#10;&#10;    suspend fun uploadProfileImage(imageUri: Uri, userId: String): String = withContext(Dispatchers.IO) {&#10;        val imageRef = storage.reference.child(&quot;profile_images/$userId.jpg&quot;)&#10;        imageRef.putFile(imageUri).await()&#10;        imageRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    suspend fun saveUserProfile(userId: String, data: Map&lt;String, Any&gt;): Unit = withContext(Dispatchers.IO) {&#10;        firestore.collection(&quot;users&quot;).document(userId).set(data).await()&#10;    }&#10;&#10;    suspend fun updateUserProfileField(userId: String, field: String, value: Any): Unit = withContext(Dispatchers.IO) {&#10;        firestore.collection(&quot;users&quot;).document(userId).update(field, value).await()&#10;    }&#10;&#10;    suspend fun savePost(post: Post): String? = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val result = firestore.collection(&quot;posts&quot;).add(post).await()&#10;            android.util.Log.d(&quot;UserRepository&quot;, &quot;Post guardado correctamente con ID: ${result.id}&quot;)&#10;            result.id&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al guardar post: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun uploadPostAudio(audioUri: Uri, postId: String): String = withContext(Dispatchers.IO) {&#10;        val audioRef = storage.reference.child(&quot;post_audios/$postId.m4a&quot;)&#10;        audioRef.putFile(audioUri).await()&#10;        audioRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    suspend fun incrementPlayCount(postId: String) = withContext(Dispatchers.IO) {&#10;        val postRef = firestore.collection(&quot;posts&quot;).document(postId)&#10;        firestore.runTransaction { transaction -&gt;&#10;            val snapshot = transaction.get(postRef)&#10;            val currentCount = snapshot.getLong(&quot;playCount&quot;) ?: 0L&#10;            transaction.update(postRef, &quot;playCount&quot;, currentCount + 1)&#10;        }.await()&#10;    }&#10;&#10;    suspend fun toggleLikePost(postId: String, userId: String, liked: Boolean): Boolean = withContext(Dispatchers.IO) {&#10;        val postRef = firestore.collection(&quot;posts&quot;).document(postId)&#10;        return@withContext try {&#10;            firestore.runTransaction { transaction -&gt;&#10;                val snapshot = transaction.get(postRef)&#10;                val likes = snapshot.get(&quot;likes&quot;) as? List&lt;String&gt; ?: emptyList()&#10;                val updatedLikes = if (liked) {&#10;                    if (!likes.contains(userId)) likes + userId else likes&#10;                } else {&#10;                    likes.filter { it != userId }&#10;                }&#10;                transaction.update(postRef, &quot;likes&quot;, updatedLikes)&#10;            }.await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        auth.signOut()&#10;    }&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    fun getCurrentUserId(): String? = auth.currentUser?.uid&#10;&#10;    fun getPosts(onResult: (List&lt;Post&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;posts&quot;)&#10;            .orderBy(&quot;publishedAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener posts: &quot;+error?.message)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Documentos recibidos: &quot;+snapshot.documents.size)&#10;                val posts = snapshot.documents.mapNotNull {&#10;                    val post = it.toObject(Post::class.java)&#10;                    if (post == null) {&#10;                        android.util.Log.w(&quot;UserRepository&quot;, &quot;Conversión fallida para documento: &quot;+it.id)&#10;                        android.util.Log.w(&quot;UserRepository&quot;, &quot;Contenido bruto: &quot;+it.data)&#10;                    }&#10;                    post?.copy(documentId = it.id)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Posts convertidos: &quot;+posts.size)&#10;                onResult(posts)&#10;            }&#10;    }&#10;&#10;    fun getPostsOnce(onResult: (List&lt;Post&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;posts&quot;)&#10;            .orderBy(&quot;publishedAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .get()&#10;            .addOnSuccessListener { snapshot -&gt;&#10;                val posts = snapshot.documents.mapNotNull {&#10;                    val post = it.toObject(Post::class.java)&#10;                    post?.copy(documentId = it.id)&#10;                }&#10;                onResult(posts)&#10;            }&#10;            .addOnFailureListener {&#10;                onResult(emptyList())&#10;            }&#10;    }&#10;&#10;    suspend fun clearLocalCache(context: Context) = withContext(Dispatchers.IO) {&#10;        val db = Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;app_database&quot;&#10;        ).build()&#10;        val deletedRows = db.cachedPostDao().clearAll()&#10;        android.util.Log.d(&quot;UserRepository&quot;, &quot;clearAll ejecutado, filas eliminadas: $deletedRows&quot;)&#10;        db.close()&#10;        val cacheDir = context.cacheDir&#10;        cacheDir.listFiles()?.forEach { file -&gt;&#10;            if (file.name.startsWith(&quot;audio_&quot;) || file.name.startsWith(&quot;profile_&quot;)) {&#10;                val deleted = file.delete()&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Archivo ${file.name} eliminado: $deleted&quot;)&#10;            }&#10;        }&#10;        val remainingFiles = cacheDir.listFiles()?.map { it.name } ?: emptyList()&#10;        android.util.Log.d(&quot;UserRepository&quot;, &quot;Archivos restantes en caché: $remainingFiles&quot;)&#10;    }&#10;&#10;    // ======== FUNCIONES PARA LANZAMIENTOS (ÁLBUMES Y PODCASTS) ========&#10;&#10;    suspend fun createAlbum(album: com.heypudu.heypudu.data.models.Album): String? = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val result = firestore.collection(&quot;albums&quot;).add(album).await()&#10;            android.util.Log.d(&quot;UserRepository&quot;, &quot;Álbum creado: ${result.id}&quot;)&#10;            result.id&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al crear álbum: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun createPodcast(podcast: com.heypudu.heypudu.data.models.Podcast): String? = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val result = firestore.collection(&quot;podcasts&quot;).add(podcast).await()&#10;            android.util.Log.d(&quot;UserRepository&quot;, &quot;Podcast creado: ${result.id}&quot;)&#10;            result.id&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al crear podcast: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    fun getAlbumsByUser(userId: String, onResult: (List&lt;com.heypudu.heypudu.data.models.Album&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;albums&quot;)&#10;            .whereEqualTo(&quot;artistId&quot;, userId)&#10;            .orderBy(&quot;createdAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener álbumes: ${error?.message}&quot;)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                val albums = snapshot.documents.mapNotNull {&#10;                    val album = it.toObject(com.heypudu.heypudu.data.models.Album::class.java)&#10;                    album?.copy(albumId = it.id)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Álbumes obtenidos: ${albums.size}&quot;)&#10;                onResult(albums)&#10;            }&#10;    }&#10;&#10;    fun getPodcastsByUser(userId: String, onResult: (List&lt;com.heypudu.heypudu.data.models.Podcast&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;podcasts&quot;)&#10;            .whereEqualTo(&quot;creatorId&quot;, userId)&#10;            .orderBy(&quot;createdAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener podcasts: ${error?.message}&quot;)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                val podcasts = snapshot.documents.mapNotNull {&#10;                    val podcast = it.toObject(com.heypudu.heypudu.data.models.Podcast::class.java)&#10;                    podcast?.copy(podcastId = it.id)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Podcasts obtenidos: ${podcasts.size}&quot;)&#10;                onResult(podcasts)&#10;            }&#10;    }&#10;&#10;    fun getAllPublicReleases(onResult: (List&lt;Any&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;albums&quot;)&#10;            .whereEqualTo(&quot;isPublished&quot;, true)&#10;            .orderBy(&quot;createdAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .limit(50)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener lanzamientos: ${error?.message}&quot;)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                val releases = snapshot.documents.mapNotNull {&#10;                    it.toObject(com.heypudu.heypudu.data.models.Album::class.java)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Lanzamientos públicos obtenidos: ${releases.size}&quot;)&#10;                onResult(releases)&#10;            }&#10;    }&#10;&#10;    suspend fun uploadReleaseCover(imageUri: android.net.Uri, releaseId: String, type: String): String = withContext(Dispatchers.IO) {&#10;        val coverRef = storage.reference.child(&quot;release_covers/$type/$releaseId.jpg&quot;)&#10;        coverRef.putFile(imageUri).await()&#10;        return@withContext coverRef.downloadUrl.await().toString()&#10;    }&#10;}&#10;&#10;data class Post(&#10;    val documentId: String? = null,&#10;    val authorId: String? = null,&#10;    val authorUsername: String? = null,&#10;    val authorPhotoUrl: String? = null,&#10;    val publishedAt: Long? = null,&#10;    val title: String? = null,&#10;    val content: String? = null,&#10;    val audioUrl: String? = null,&#10;    val likes: List&lt;String&gt;? = null,&#10;    val comments: List&lt;Comment&gt;? = null,&#10;    val playCount: Int? = null // contador de reproducciones&#10;)&#10;&#10;data class Comment(&#10;    val commentId: String? = null,&#10;    val authorId: String? = null,&#10;    val text: String? = null,&#10;    val audioUrl: String? = null,&#10;    val createdAt: Long? = null&#10;)&#10;" />
              <option name="updatedContent" value="package com.heypudu.heypudu.data&#10;&#10;import android.net.Uri&#10;import com.google.firebase.auth.AuthResult&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.storage.FirebaseStorage&#10;import AppDatabase&#10;import androidx.room.Room&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.withContext&#10;import android.content.Context&#10;&#10;class UserRepository(&#10;    private val auth: FirebaseAuth = FirebaseAuth.getInstance(),&#10;    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance(),&#10;    private val storage: FirebaseStorage = FirebaseStorage.getInstance()&#10;) {&#10;&#10;    suspend fun createUser(email: String, password: String): AuthResult = withContext(Dispatchers.IO) {&#10;        // No hacemos signOut aquí: que lo controle el ViewModel si lo requiere&#10;        auth.createUserWithEmailAndPassword(email, password).await()&#10;    }&#10;&#10;    suspend fun sendEmailVerification(): Unit = withContext(Dispatchers.IO) {&#10;        val user = auth.currentUser ?: throw IllegalStateException(&quot;No authenticated user&quot;)&#10;        user.sendEmailVerification().await()&#10;    }&#10;&#10;    suspend fun uploadProfileImage(imageUri: Uri, userId: String): String = withContext(Dispatchers.IO) {&#10;        val imageRef = storage.reference.child(&quot;profile_images/$userId.jpg&quot;)&#10;        imageRef.putFile(imageUri).await()&#10;        imageRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    suspend fun uploadProfilePhoto(imageUri: Uri, userId: String): String = withContext(Dispatchers.IO) {&#10;        val timestamp = System.currentTimeMillis()&#10;        val imageRef = storage.reference.child(&quot;profile_photos/$userId/$timestamp.jpg&quot;)&#10;        imageRef.putFile(imageUri).await()&#10;        imageRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    suspend fun saveUserProfile(userId: String, data: Map&lt;String, Any&gt;): Unit = withContext(Dispatchers.IO) {&#10;        firestore.collection(&quot;users&quot;).document(userId).set(data).await()&#10;    }&#10;&#10;    suspend fun updateUserProfileField(userId: String, field: String, value: Any): Unit = withContext(Dispatchers.IO) {&#10;        firestore.collection(&quot;users&quot;).document(userId).update(field, value).await()&#10;    }&#10;&#10;    suspend fun savePost(post: Post): String? = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val result = firestore.collection(&quot;posts&quot;).add(post).await()&#10;            android.util.Log.d(&quot;UserRepository&quot;, &quot;Post guardado correctamente con ID: ${result.id}&quot;)&#10;            result.id&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al guardar post: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun uploadPostAudio(audioUri: Uri, postId: String): String = withContext(Dispatchers.IO) {&#10;        val audioRef = storage.reference.child(&quot;post_audios/$postId.m4a&quot;)&#10;        audioRef.putFile(audioUri).await()&#10;        audioRef.downloadUrl.await().toString()&#10;    }&#10;&#10;    suspend fun incrementPlayCount(postId: String) = withContext(Dispatchers.IO) {&#10;        val postRef = firestore.collection(&quot;posts&quot;).document(postId)&#10;        firestore.runTransaction { transaction -&gt;&#10;            val snapshot = transaction.get(postRef)&#10;            val currentCount = snapshot.getLong(&quot;playCount&quot;) ?: 0L&#10;            transaction.update(postRef, &quot;playCount&quot;, currentCount + 1)&#10;        }.await()&#10;    }&#10;&#10;    suspend fun toggleLikePost(postId: String, userId: String, liked: Boolean): Boolean = withContext(Dispatchers.IO) {&#10;        val postRef = firestore.collection(&quot;posts&quot;).document(postId)&#10;        return@withContext try {&#10;            firestore.runTransaction { transaction -&gt;&#10;                val snapshot = transaction.get(postRef)&#10;                val likes = snapshot.get(&quot;likes&quot;) as? List&lt;String&gt; ?: emptyList()&#10;                val updatedLikes = if (liked) {&#10;                    if (!likes.contains(userId)) likes + userId else likes&#10;                } else {&#10;                    likes.filter { it != userId }&#10;                }&#10;                transaction.update(postRef, &quot;likes&quot;, updatedLikes)&#10;            }.await()&#10;            true&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        auth.signOut()&#10;    }&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    fun getCurrentUserId(): String? = auth.currentUser?.uid&#10;&#10;    fun getPosts(onResult: (List&lt;Post&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;posts&quot;)&#10;            .orderBy(&quot;publishedAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener posts: &quot;+error?.message)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Documentos recibidos: &quot;+snapshot.documents.size)&#10;                val posts = snapshot.documents.mapNotNull {&#10;                    val post = it.toObject(Post::class.java)&#10;                    if (post == null) {&#10;                        android.util.Log.w(&quot;UserRepository&quot;, &quot;Conversión fallida para documento: &quot;+it.id)&#10;                        android.util.Log.w(&quot;UserRepository&quot;, &quot;Contenido bruto: &quot;+it.data)&#10;                    }&#10;                    post?.copy(documentId = it.id)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Posts convertidos: &quot;+posts.size)&#10;                onResult(posts)&#10;            }&#10;    }&#10;&#10;    fun getPostsOnce(onResult: (List&lt;Post&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;posts&quot;)&#10;            .orderBy(&quot;publishedAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .get()&#10;            .addOnSuccessListener { snapshot -&gt;&#10;                val posts = snapshot.documents.mapNotNull {&#10;                    val post = it.toObject(Post::class.java)&#10;                    post?.copy(documentId = it.id)&#10;                }&#10;                onResult(posts)&#10;            }&#10;            .addOnFailureListener {&#10;                onResult(emptyList())&#10;            }&#10;    }&#10;&#10;    suspend fun clearLocalCache(context: Context) = withContext(Dispatchers.IO) {&#10;        val db = Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;app_database&quot;&#10;        ).build()&#10;        val deletedRows = db.cachedPostDao().clearAll()&#10;        android.util.Log.d(&quot;UserRepository&quot;, &quot;clearAll ejecutado, filas eliminadas: $deletedRows&quot;)&#10;        db.close()&#10;        val cacheDir = context.cacheDir&#10;        cacheDir.listFiles()?.forEach { file -&gt;&#10;            if (file.name.startsWith(&quot;audio_&quot;) || file.name.startsWith(&quot;profile_&quot;)) {&#10;                val deleted = file.delete()&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Archivo ${file.name} eliminado: $deleted&quot;)&#10;            }&#10;        }&#10;        val remainingFiles = cacheDir.listFiles()?.map { it.name } ?: emptyList()&#10;        android.util.Log.d(&quot;UserRepository&quot;, &quot;Archivos restantes en caché: $remainingFiles&quot;)&#10;    }&#10;&#10;    // ======== FUNCIONES PARA LANZAMIENTOS (ÁLBUMES Y PODCASTS) ========&#10;&#10;    suspend fun createAlbum(album: com.heypudu.heypudu.data.models.Album): String? = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val result = firestore.collection(&quot;albums&quot;).add(album).await()&#10;            android.util.Log.d(&quot;UserRepository&quot;, &quot;Álbum creado: ${result.id}&quot;)&#10;            result.id&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al crear álbum: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    suspend fun createPodcast(podcast: com.heypudu.heypudu.data.models.Podcast): String? = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val result = firestore.collection(&quot;podcasts&quot;).add(podcast).await()&#10;            android.util.Log.d(&quot;UserRepository&quot;, &quot;Podcast creado: ${result.id}&quot;)&#10;            result.id&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al crear podcast: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    fun getAlbumsByUser(userId: String, onResult: (List&lt;com.heypudu.heypudu.data.models.Album&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;albums&quot;)&#10;            .whereEqualTo(&quot;artistId&quot;, userId)&#10;            .orderBy(&quot;createdAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener álbumes: ${error?.message}&quot;)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                val albums = snapshot.documents.mapNotNull {&#10;                    val album = it.toObject(com.heypudu.heypudu.data.models.Album::class.java)&#10;                    album?.copy(albumId = it.id)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Álbumes obtenidos: ${albums.size}&quot;)&#10;                onResult(albums)&#10;            }&#10;    }&#10;&#10;    fun getPodcastsByUser(userId: String, onResult: (List&lt;com.heypudu.heypudu.data.models.Podcast&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;podcasts&quot;)&#10;            .whereEqualTo(&quot;creatorId&quot;, userId)&#10;            .orderBy(&quot;createdAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener podcasts: ${error?.message}&quot;)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                val podcasts = snapshot.documents.mapNotNull {&#10;                    val podcast = it.toObject(com.heypudu.heypudu.data.models.Podcast::class.java)&#10;                    podcast?.copy(podcastId = it.id)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Podcasts obtenidos: ${podcasts.size}&quot;)&#10;                onResult(podcasts)&#10;            }&#10;    }&#10;&#10;    fun getAllPublicReleases(onResult: (List&lt;Any&gt;) -&gt; Unit) {&#10;        firestore.collection(&quot;albums&quot;)&#10;            .whereEqualTo(&quot;isPublished&quot;, true)&#10;            .orderBy(&quot;createdAt&quot;, com.google.firebase.firestore.Query.Direction.DESCENDING)&#10;            .limit(50)&#10;            .addSnapshotListener { snapshot, error -&gt;&#10;                if (error != null || snapshot == null) {&#10;                    android.util.Log.e(&quot;UserRepository&quot;, &quot;Error al obtener lanzamientos: ${error?.message}&quot;)&#10;                    onResult(emptyList())&#10;                    return@addSnapshotListener&#10;                }&#10;                val releases = snapshot.documents.mapNotNull {&#10;                    it.toObject(com.heypudu.heypudu.data.models.Album::class.java)&#10;                }&#10;                android.util.Log.d(&quot;UserRepository&quot;, &quot;Lanzamientos públicos obtenidos: ${releases.size}&quot;)&#10;                onResult(releases)&#10;            }&#10;    }&#10;&#10;    suspend fun uploadReleaseCover(imageUri: android.net.Uri, releaseId: String, type: String): String = withContext(Dispatchers.IO) {&#10;        val coverRef = storage.reference.child(&quot;release_covers/$type/$releaseId.jpg&quot;)&#10;        coverRef.putFile(imageUri).await()&#10;        return@withContext coverRef.downloadUrl.await().toString()&#10;    }&#10;}&#10;&#10;data class Post(&#10;    val documentId: String? = null,&#10;    val authorId: String? = null,&#10;    val authorUsername: String? = null,&#10;    val authorPhotoUrl: String? = null,&#10;    val publishedAt: Long? = null,&#10;    val title: String? = null,&#10;    val content: String? = null,&#10;    val audioUrl: String? = null,&#10;    val likes: List&lt;String&gt;? = null,&#10;    val comments: List&lt;Comment&gt;? = null,&#10;    val playCount: Int? = null // contador de reproducciones&#10;)&#10;&#10;data class Comment(&#10;    val commentId: String? = null,&#10;    val authorId: String? = null,&#10;    val text: String? = null,&#10;    val audioUrl: String? = null,&#10;    val createdAt: Long? = null&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/heypudu/heypudu/features/profile/navigation/ProfileNavGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/heypudu/heypudu/features/profile/navigation/ProfileNavGraph.kt" />
              <option name="originalContent" value="package com.heypudu.heypudu.features.profile.navigation&#10;&#10;import androidx.navigation.NavGraphBuilder&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navigation&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import com.heypudu.heypudu.features.profile.ui.EditProfileScreen&#10;import com.heypudu.heypudu.features.profile.ui.ProfileScreen&#10;&#10;object ProfileRoutes {&#10;    const val GRAPH = &quot;profile_graph&quot;&#10;    const val VIEW = &quot;profile_view&quot;&#10;    const val EDIT = &quot;profile_edit&quot;&#10;}&#10;&#10;fun NavGraphBuilder.profileGraph(navController: NavHostController) {&#10;    navigation(&#10;        startDestination = ProfileRoutes.VIEW,&#10;        route = ProfileRoutes.GRAPH&#10;    ) {&#10;        composable(&#10;            route = ProfileRoutes.VIEW + &quot;?userId={userId}&quot;,&#10;            arguments = listOf(navArgument(&quot;userId&quot;) { type = NavType.StringType; nullable = true })&#10;        ) { navBackStackEntry -&gt;&#10;            val userId = navBackStackEntry.arguments?.getString(&quot;userId&quot;)&#10;            ProfileScreen(&#10;                userId = userId,&#10;                navController = navController,&#10;                onGoToEdit = { navController.navigate(ProfileRoutes.EDIT) },&#10;                onBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.heypudu.heypudu.features.profile.navigation&#10;&#10;import androidx.navigation.NavGraphBuilder&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navigation&#10;import androidx.navigation.NavType&#10;import androidx.navigation.navArgument&#10;import com.heypudu.heypudu.features.profile.ui.EditProfileScreen&#10;import com.heypudu.heypudu.features.profile.ui.ProfileScreen&#10;&#10;object ProfileRoutes {&#10;    const val GRAPH = &quot;profile_graph&quot;&#10;    const val VIEW = &quot;profile_view&quot;&#10;    const val EDIT = &quot;profile_edit&quot;&#10;}&#10;&#10;fun NavGraphBuilder.profileGraph(navController: NavHostController) {&#10;    navigation(&#10;        startDestination = ProfileRoutes.VIEW,&#10;        route = ProfileRoutes.GRAPH&#10;    ) {&#10;        composable(&#10;            route = ProfileRoutes.VIEW + &quot;?userId={userId}&quot;,&#10;            arguments = listOf(navArgument(&quot;userId&quot;) { type = NavType.StringType; nullable = true })&#10;        ) { navBackStackEntry -&gt;&#10;            val userId = navBackStackEntry.arguments?.getString(&quot;userId&quot;)&#10;            ProfileScreen(&#10;                userId = userId,&#10;                navController = navController,&#10;                onGoToEdit = { navController.navigate(ProfileRoutes.EDIT + &quot;?userId=$userId&quot;) },&#10;                onBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;        &#10;        composable(&#10;            route = ProfileRoutes.EDIT + &quot;?userId={userId}&quot;,&#10;            arguments = listOf(navArgument(&quot;userId&quot;) { type = NavType.StringType; nullable = false })&#10;        ) { navBackStackEntry -&gt;&#10;            val userId = navBackStackEntry.arguments?.getString(&quot;userId&quot;) ?: &quot;&quot;&#10;            EditProfileScreen(&#10;                userId = userId,&#10;                navController = navController&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/heypudu/heypudu/features/profile/ui/EditProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/heypudu/heypudu/features/profile/ui/EditProfileScreen.kt" />
              <option name="originalContent" value="package com.heypudu.heypudu.features.profile.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import com.heypudu.heypudu.ui.components.ProfileImagePicker&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.mutableStateOf&#10;import android.net.Uri&#10;&#10;@Composable&#10;fun EditProfileScreen(&#10;    onSave: () -&gt; Unit&#10;) {&#10;    val imageUri = remember { mutableStateOf&lt;Uri?&gt;(null) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize(),&#10;        verticalArrangement = Arrangement.Center,&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&quot;Pantalla de Edición de Perfil&quot;)&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        ProfileImagePicker(imageUri = imageUri)&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        Button(onClick = onSave) {&#10;            Text(&quot;Guardar y Volver&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.heypudu.heypudu.features.profile.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavHostController&#10;import android.net.Uri&#10;import com.heypudu.heypudu.data.UserRepository&#10;import com.heypudu.heypudu.features.profile.viewmodel.ProfileViewModel&#10;import com.heypudu.heypudu.ui.components.ProfileImage&#10;import com.heypudu.heypudu.ui.components.ProfileImagePicker&#10;import com.heypudu.heypudu.ui.components.AnimatedGradientBackground&#10;import com.google.firebase.auth.FirebaseAuth&#10;import kotlinx.coroutines.launch&#10;import android.util.Log&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun EditProfileScreen(&#10;    userId: String,&#10;    navController: NavHostController&#10;) {&#10;    val viewModel: ProfileViewModel = viewModel()&#10;    val repo = UserRepository()&#10;    val scope = rememberCoroutineScope()&#10;    val auth = FirebaseAuth.getInstance()&#10;    &#10;    // Estados para los campos&#10;    var username by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedImageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var errorMessage by remember { mutableStateOf(&quot;&quot;) }&#10;    var successMessage by remember { mutableStateOf(&quot;&quot;) }&#10;    &#10;    val currentUsername by viewModel.username.collectAsState()&#10;    val currentPhotoUrl by viewModel.photoUrl.collectAsState()&#10;    &#10;    // Cargar datos actuales&#10;    LaunchedEffect(userId) {&#10;        viewModel.loadUser(userId)&#10;        username = currentUsername&#10;    }&#10;    &#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        AnimatedGradientBackground()&#10;        &#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // TopBar&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                IconButton(&#10;                    onClick = { navController.popBackStack() }&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Filled.ArrowBack,&#10;                        contentDescription = &quot;Volver&quot;,&#10;                        tint = Color.White&#10;                    )&#10;                }&#10;                Text(&#10;                    text = &quot;Editar Perfil&quot;,&#10;                    fontSize = 20.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color.White&#10;                )&#10;                Spacer(modifier = Modifier.width(48.dp))&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            &#10;            // Foto de perfil actual&#10;            if (currentPhotoUrl.isNotEmpty()) {&#10;                Text(&#10;                    text = &quot;Foto Actual&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = Color.White.copy(alpha = 0.8f),&#10;                    modifier = Modifier.align(Alignment.Start).padding(start = 16.dp)&#10;                )&#10;                ProfileImage(&#10;                    photoUrl = currentPhotoUrl,&#10;                    size = 120.dp,&#10;                    modifier = Modifier.padding(vertical = 12.dp)&#10;                )&#10;            }&#10;            &#10;            // Selector de foto&#10;            Text(&#10;                text = &quot;Nueva Foto&quot;,&#10;                fontSize = 14.sp,&#10;                color = Color.White.copy(alpha = 0.8f),&#10;                modifier = Modifier.align(Alignment.Start).padding(start = 16.dp)&#10;            )&#10;            ProfileImagePicker(&#10;                imageUri = remember { mutableStateOf(selectedImageUri) }.apply {&#10;                    value = selectedImageUri&#10;                },&#10;                onImageSelected = { uri -&gt;&#10;                    selectedImageUri = uri&#10;                    Log.d(&quot;EditProfile&quot;, &quot;Imagen seleccionada: $uri&quot;)&#10;                },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;                    .padding(vertical = 12.dp)&#10;            )&#10;            &#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            &#10;            // Campo de nombre de usuario&#10;            Text(&#10;                text = &quot;Nombre de Usuario&quot;,&#10;                fontSize = 14.sp,&#10;                color = Color.White.copy(alpha = 0.8f),&#10;                modifier = Modifier.align(Alignment.Start).padding(start = 16.dp)&#10;            )&#10;            OutlinedTextField(&#10;                value = username,&#10;                onValueChange = { username = it },&#10;                label = { Text(&quot;Nombre de usuario&quot;) },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp)&#10;                    .padding(vertical = 8.dp),&#10;                singleLine = true,&#10;                colors = OutlinedTextFieldDefaults.colors(&#10;                    focusedTextColor = Color.White,&#10;                    unfocusedTextColor = Color.White,&#10;                    focusedBorderColor = Color(0xFFE91E63),&#10;                    unfocusedBorderColor = Color.White.copy(alpha = 0.5f),&#10;                    focusedLabelColor = Color(0xFFE91E63),&#10;                    unfocusedLabelColor = Color.White.copy(alpha = 0.7f)&#10;                )&#10;            )&#10;            &#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            &#10;            // Mensajes de error o éxito&#10;            if (errorMessage.isNotEmpty()) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    color = Color(0xFFFF6B6B),&#10;                    fontSize = 12.sp,&#10;                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;            &#10;            if (successMessage.isNotEmpty()) {&#10;                Text(&#10;                    text = successMessage,&#10;                    color = Color(0xFF4CAF50),&#10;                    fontSize = 12.sp,&#10;                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(24.dp))&#10;            &#10;            // Botones&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Button(&#10;                    onClick = { navController.popBackStack() },&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .height(48.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color.White.copy(alpha = 0.3f)&#10;                    )&#10;                ) {&#10;                    Text(&quot;Cancelar&quot;, color = Color.White)&#10;                }&#10;                &#10;                Button(&#10;                    onClick = {&#10;                        scope.launch {&#10;                            isLoading = true&#10;                            errorMessage = &quot;&quot;&#10;                            successMessage = &quot;&quot;&#10;                            &#10;                            try {&#10;                                // Actualizar nombre de usuario&#10;                                if (username.isNotBlank() &amp;&amp; username != currentUsername) {&#10;                                    repo.updateUserProfileField(userId, &quot;username&quot;, username)&#10;                                    Log.d(&quot;EditProfile&quot;, &quot;Nombre de usuario actualizado: $username&quot;)&#10;                                }&#10;                                &#10;                                // Subir foto si fue seleccionada&#10;                                if (selectedImageUri != null) {&#10;                                    val photoUrl = repo.uploadProfilePhoto(selectedImageUri!!, userId)&#10;                                    repo.updateUserProfileField(userId, &quot;photoUrl&quot;, photoUrl)&#10;                                    Log.d(&quot;EditProfile&quot;, &quot;Foto actualizada: $photoUrl&quot;)&#10;                                }&#10;                                &#10;                                successMessage = &quot;Perfil actualizado correctamente&quot;&#10;                                // Recargar datos&#10;                                viewModel.loadUser(userId)&#10;                                &#10;                                // Volver después de 1.5 segundos&#10;                                kotlinx.coroutines.delay(1500)&#10;                                navController.popBackStack()&#10;                            } catch (e: Exception) {&#10;                                errorMessage = &quot;Error: ${e.message}&quot;&#10;                                Log.e(&quot;EditProfile&quot;, &quot;Error al guardar: ${e.message}&quot;)&#10;                            } finally {&#10;                                isLoading = false&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .height(48.dp),&#10;                    enabled = !isLoading &amp;&amp; (username.isNotBlank() || selectedImageUri != null),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = Color(0xFFE91E63)&#10;                    )&#10;                ) {&#10;                    if (isLoading) {&#10;                        CircularProgressIndicator(&#10;                            color = Color.White,&#10;                            modifier = Modifier.size(20.dp)&#10;                        )&#10;                    } else {&#10;                        Text(&quot;Guardar&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>